'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = require('fs');
var fs__default = _interopDefault(fs);
var path = require('path');
var path__default = _interopDefault(path);
var __chunk_4 = require('./chunk-7cffb8b5.js');
var module$1 = _interopDefault(require('module'));
var __chunk_2 = require('./chunk-21b7786f.js');
var hash = _interopDefault(require('string-hash'));
var codec = require('sourcemap-codec');
var prettyBytes = require('./pretty-bytes.js');
var tslib_1 = require('tslib');
var __chunk_5 = require('./chunk-abdec9a5.js');

function create_main_manifests(_a) {
    var bundler = _a.bundler, manifest_data = _a.manifest_data, dev_port = _a.dev_port, dev = _a.dev, cwd = _a.cwd, src = _a.src, dest = _a.dest, routes = _a.routes, output = _a.output;
    if (!fs.existsSync(output))
        fs.mkdirSync(output);
    var path_to_routes = path.relative(output, routes);
    var client_manifest = generate_client(manifest_data, path_to_routes, bundler, dev, dev_port);
    var server_manifest = generate_server(manifest_data, path_to_routes, cwd, src, dest, dev);
    __chunk_4.write_if_changed(output + "/_layout.html", "<svelte:component this={child.component} {...child.props}/>");
    __chunk_4.write_if_changed(output + "/client.js", client_manifest);
    __chunk_4.write_if_changed(output + "/server.js", server_manifest);
}
function create_serviceworker_manifest(_a) {
    var manifest_data = _a.manifest_data, output = _a.output, client_files = _a.client_files, static_files = _a.static_files;
    var files = ['/service-worker-index.html'];
    if (fs.existsSync(static_files)) {
        files = files.concat(__chunk_4.walk(static_files));
    }
    else {
        // TODO remove in a future version
        if (fs.existsSync('assets')) {
            throw new Error("As of Sapper 0.21, the assets/ directory should become static/");
        }
    }
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\texport const timestamp = " + Date.now() + ";\n\n\t\texport const files = [\n\t" + files.map(function (x) { return __chunk_4.stringify(x); }).join(',\n\t') + "\n];\n\t\texport { files as assets }; // legacy\n\n\t\texport const shell = [\n\t" + client_files.map(function (x) { return __chunk_4.stringify(x); }).join(',\n\t') + "\n];\n\n\t\texport const routes = [\n\t" + manifest_data.pages.map(function (r) { return "{ pattern: " + r.pattern + " }"; }).join(',\n\t') + "\n];\n\t").replace(/^\t\t/gm, '').trim();
    __chunk_4.write_if_changed(output + "/service-worker.js", code);
}
function generate_client(manifest_data, path_to_routes, bundler, dev, dev_port) {
    var template_file = path.resolve(__dirname, '../templates/client.js');
    var template = fs.readFileSync(template_file, 'utf-8');
    var page_ids = new Set(manifest_data.pages.map(function (page) {
        return page.pattern.toString();
    }));
    var server_routes_to_ignore = manifest_data.server_routes.filter(function (route) {
        return !page_ids.has(route.pattern.toString());
    });
    var component_indexes = {};
    var components = ("[\n\t\t" + manifest_data.components.map(function (component, i) {
        var annotation = bundler === 'webpack'
            ? "/* webpackChunkName: \"" + component.name + "\" */ "
            : '';
        var source = get_file(path_to_routes, component);
        component_indexes[component.name] = i;
        return "{\n\t\t\tjs: () => import(" + annotation + __chunk_4.stringify(source) + "),\n\t\t\tcss: \"__SAPPER_CSS_PLACEHOLDER:" + __chunk_4.stringify(component.file, false) + "__\"\n\t\t}";
    }).join(',\n\t\t') + "\n\t]").replace(/^\t/gm, '').trim();
    var needs_decode = false;
    var pages = ("[\n\t\t" + manifest_data.pages.map(function (page) { return "{\n\t\t\t// " + page.parts[page.parts.length - 1].component.file + "\n\t\t\tpattern: " + page.pattern + ",\n\t\t\tparts: [\n\t\t\t\t" + page.parts.map(function (part) {
        if (part === null)
            return 'null';
        if (part.params.length > 0) {
            needs_decode = true;
            var props = part.params.map(function (param, i) { return param + ": d(match[" + (i + 1) + "])"; });
            return "{ i: " + component_indexes[part.component.name] + ", params: match => ({ " + props.join(', ') + " }) }";
        }
        return "{ i: " + component_indexes[part.component.name] + " }";
    }).join(',\n\t\t\t\t') + "\n\t\t\t]\n\t\t}"; }).join(',\n\n\t\t') + "\n\t]").replace(/^\t/gm, '').trim();
    if (needs_decode) {
        pages = "(d => " + pages + ")(decodeURIComponent)";
    }
    var footer = '';
    if (dev) {
        var sapper_dev_client = __chunk_4.posixify(path.resolve(__dirname, '../sapper-dev-client.js'));
        footer = ("\n\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\timport(" + __chunk_4.stringify(sapper_dev_client) + ").then(client => {\n\t\t\t\t\tclient.connect(" + dev_port + ");\n\t\t\t\t});\n\t\t\t}").replace(/^\t{3}/gm, '');
    }
    return "// This file is generated by Sapper \u2014 do not edit it!\n" + template
        .replace('__ROOT__', __chunk_4.stringify(get_file(path_to_routes, manifest_data.root), false))
        .replace('__ERROR__', __chunk_4.stringify(__chunk_4.posixify(path_to_routes + "/_error.html"), false))
        .replace('__IGNORE__', "[" + server_routes_to_ignore.map(function (route) { return route.pattern; }).join(', ') + "]")
        .replace('__COMPONENTS__', components)
        .replace('__PAGES__', pages) +
        footer;
}
function generate_server(manifest_data, path_to_routes, cwd, src, dest, dev) {
    var template_file = path.resolve(__dirname, '../templates/server.js');
    var template = fs.readFileSync(template_file, 'utf-8');
    var imports = [].concat(manifest_data.server_routes.map(function (route) {
        return "import * as __" + route.name + " from " + __chunk_4.stringify(__chunk_4.posixify(path_to_routes + "/" + route.file)) + ";";
    }), manifest_data.components.map(function (component) {
        return "import __" + component.name + " from " + __chunk_4.stringify(get_file(path_to_routes, component)) + ";";
    }), "import root from " + __chunk_4.stringify(get_file(path_to_routes, manifest_data.root)) + ";", "import error from " + __chunk_4.stringify(__chunk_4.posixify(path_to_routes + "/_error.html")) + ";");
    var code = ("\n\t\t" + imports.join('\n') + "\n\n\t\tconst d = decodeURIComponent;\n\n\t\texport const manifest = {\n\t\t\tserver_routes: [\n\t\t\t\t" + manifest_data.server_routes.map(function (route) { return "{\n\t\t\t\t\t// " + route.file + "\n\t\t\t\t\tpattern: " + route.pattern + ",\n\t\t\t\t\thandlers: __" + route.name + ",\n\t\t\t\t\tparams: " + (route.params.length > 0
        ? "match => ({ " + route.params.map(function (param, i) { return param + ": d(match[" + (i + 1) + "])"; }).join(', ') + " })"
        : "() => ({})") + "\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t\t\t],\n\n\t\t\tpages: [\n\t\t\t\t" + manifest_data.pages.map(function (page) { return "{\n\t\t\t\t\t// " + page.parts[page.parts.length - 1].component.file + "\n\t\t\t\t\tpattern: " + page.pattern + ",\n\t\t\t\t\tparts: [\n\t\t\t\t\t\t" + page.parts.map(function (part) {
        if (part === null)
            return 'null';
        var props = [
            "name: \"" + part.component.name + "\"",
            "file: " + __chunk_4.stringify(part.component.file),
            "component: __" + part.component.name
        ];
        if (part.params.length > 0) {
            var params = part.params.map(function (param, i) { return param + ": d(match[" + (i + 1) + "])"; });
            props.push("params: match => ({ " + params.join(', ') + " })");
        }
        return "{ " + props.join(', ') + " }";
    }).join(',\n\t\t\t\t\t\t') + "\n\t\t\t\t\t]\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t\t\t],\n\n\t\t\troot,\n\n\t\t\terror\n\t\t};").replace(/^\t\t/gm, '').trim();
    var build_dir = __chunk_4.posixify(path.relative(cwd, dest));
    var src_dir = __chunk_4.posixify(path.relative(cwd, src));
    return "// This file is generated by Sapper \u2014 do not edit it!\n" + template
        .replace('__BUILD__DIR__', JSON.stringify(build_dir))
        .replace('__SRC__DIR__', JSON.stringify(src_dir))
        .replace('__DEV__', dev ? 'true' : 'false')
        .replace(/const manifest = __MANIFEST__;/, code);
}
function get_file(path_to_routes, component) {
    if (component.default) {
        return "./_layout.html";
    }
    return __chunk_4.posixify(path_to_routes + "/" + component.file);
}

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? __chunk_2.pathModule.resolve(dir) : process.cwd();
  var rootName = __chunk_2.pathModule.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var requireRelative_1 = requireRelative;

var inline_sourcemap_header = 'data:application/json;charset=utf-8;base64,';
function extract_sourcemap(raw, id) {
    var raw_map;
    var map = null;
    var code = raw.replace(/\/\*#\s+sourceMappingURL=(.+)\s+\*\//g, function (m, url) {
        if (raw_map) {
            // TODO should not happen!
            throw new Error("Found multiple sourcemaps in single CSS file (" + id + ")");
        }
        raw_map = url;
        return '';
    }).trim();
    if (raw_map) {
        if (raw_map.startsWith(inline_sourcemap_header)) {
            var json = Buffer.from(raw_map.slice(inline_sourcemap_header.length), 'base64').toString();
            map = JSON.parse(json);
        }
    }
    return {
        code: code,
        map: map
    };
}
function get_css_from_modules(modules, css_map, dirs) {
    var parts = [];
    var mappings = [];
    var combined_map = {
        version: 3,
        file: null,
        sources: [],
        sourcesContent: [],
        names: [],
        mappings: null
    };
    modules.forEach(function (module) {
        var _a, _b, _c;
        if (!/\.css$/.test(module))
            return;
        var css = css_map.get(module);
        var _d = extract_sourcemap(css, module), code = _d.code, map = _d.map;
        parts.push(code);
        if (map) {
            var lines = codec.decode(map.mappings);
            if (combined_map.sources.length > 0 || combined_map.names.length > 0) {
                lines.forEach(function (line) {
                    line.forEach(function (segment) {
                        // adjust source index
                        segment[1] += combined_map.sources.length;
                        // adjust name index
                        if (segment[4])
                            segment[4] += combined_map.names.length;
                    });
                });
            }
            (_a = combined_map.sources).push.apply(_a, map.sources);
            (_b = combined_map.sourcesContent).push.apply(_b, map.sourcesContent);
            (_c = combined_map.names).push.apply(_c, map.names);
            mappings.push.apply(mappings, lines);
        }
    });
    if (parts.length > 0) {
        combined_map.mappings = codec.encode(mappings);
        combined_map.sources = combined_map.sources.map(function (source) { return path.relative(dirs.dest + "/client", source); });
        return {
            code: parts.join('\n'),
            map: combined_map
        };
    }
    return null;
}
function extract_css(client_result, components, dirs) {
    var result = {
        main: null,
        chunks: {}
    };
    if (!client_result.css_files)
        return; // Rollup-only for now
    var asset_dir = dirs.dest + "/client";
    if (process.env.SAPPER_LEGACY_BUILD)
        asset_dir += '/legacy';
    var unclaimed = new Set(client_result.css_files.map(function (x) { return x.id; }));
    var lookup = new Map();
    client_result.chunks.forEach(function (chunk) {
        lookup.set(chunk.file, chunk);
    });
    var css_map = new Map();
    client_result.css_files.forEach(function (css_module) {
        css_map.set(css_module.id, css_module.code);
    });
    var chunks_with_css = new Set();
    // concatenate and emit CSS
    client_result.chunks.forEach(function (chunk) {
        var css_modules = chunk.modules.filter(function (m) { return css_map.has(m); });
        if (!css_modules.length)
            return;
        var css = get_css_from_modules(css_modules, css_map, dirs);
        var code = css.code, map = css.map;
        var output_file_name = chunk.file.replace(/\.js$/, '.css');
        map.file = output_file_name;
        map.sources = map.sources.map(function (source) { return path.relative("" + asset_dir, source); });
        fs.writeFileSync(asset_dir + "/" + output_file_name, code + "\n/* sourceMappingURL=./" + output_file_name + ".map */");
        fs.writeFileSync(asset_dir + "/" + output_file_name + ".map", JSON.stringify(map, null, '  '));
        chunks_with_css.add(chunk);
    });
    var entry = path.resolve(dirs.src, 'client.js');
    var entry_chunk = client_result.chunks.find(function (chunk) { return chunk.modules.indexOf(entry) !== -1; });
    var entry_chunk_dependencies = new Set([entry_chunk]);
    var entry_css_modules = [];
    // recursively find the chunks this component depends on
    entry_chunk_dependencies.forEach(function (chunk) {
        chunk.imports.forEach(function (file) {
            entry_chunk_dependencies.add(lookup.get(file));
        });
        if (chunks_with_css.has(chunk)) {
            chunk.modules.forEach(function (file) {
                unclaimed.delete(file);
                if (css_map.has(file)) {
                    entry_css_modules.push(file);
                }
            });
        }
    });
    // figure out which (css-having) chunks each component depends on
    components.forEach(function (component) {
        var resolved = path.resolve(dirs.routes, component.file);
        var chunk = client_result.chunks.find(function (chunk) { return chunk.modules.indexOf(resolved) !== -1; });
        if (!chunk) {
            // this should never happen!
            throw new Error("Could not find chunk that owns " + component.file);
        }
        var chunk_dependencies = new Set([chunk]);
        var css_dependencies = [];
        // recursively find the chunks this component depends on
        chunk_dependencies.forEach(function (chunk) {
            chunk.imports.forEach(function (file) {
                chunk_dependencies.add(lookup.get(file));
            });
            if (chunks_with_css.has(chunk)) {
                css_dependencies.push(chunk.file.replace(/\.js$/, '.css'));
                chunk.modules.forEach(function (file) {
                    unclaimed.delete(file);
                });
            }
        });
        result.chunks[component.file] = css_dependencies;
    });
    fs.readdirSync(asset_dir).forEach(function (file) {
        if (fs.statSync(asset_dir + "/" + file).isDirectory())
            return;
        var source = fs.readFileSync(asset_dir + "/" + file, 'utf-8');
        var replaced = source.replace(/["']__SAPPER_CSS_PLACEHOLDER:(.+?)__["']/g, function (m, route) {
            return JSON.stringify(result.chunks[route]);
        });
        fs.writeFileSync(asset_dir + "/" + file, replaced);
    });
    unclaimed.forEach(function (file) {
        entry_css_modules.push(file);
    });
    var leftover = get_css_from_modules(entry_css_modules, css_map, dirs);
    if (leftover) {
        var code = leftover.code, map = leftover.map;
        var main_hash = hash(code);
        var output_file_name = "main." + main_hash + ".css";
        map.file = output_file_name;
        map.sources = map.sources.map(function (source) { return path.relative(asset_dir, source); });
        fs.writeFileSync(asset_dir + "/" + output_file_name, code + "\n/* sourceMappingURL=client/" + output_file_name + ".map */");
        fs.writeFileSync(asset_dir + "/" + output_file_name + ".map", JSON.stringify(map, null, '  '));
        result.main = output_file_name;
    }
    return result;
}

var RollupResult = /** @class */ (function () {
    function RollupResult(duration, compiler) {
        var _this = this;
        this.duration = duration;
        this.errors = compiler.errors.map(munge_warning_or_error);
        this.warnings = compiler.warnings.map(munge_warning_or_error); // TODO emit this as they happen
        this.chunks = compiler.chunks.map(function (chunk) { return ({
            file: chunk.fileName,
            imports: chunk.imports.filter(Boolean),
            modules: Object.keys(chunk.modules)
        }); });
        this.css_files = compiler.css_files;
        // TODO populate this properly. We don't have named chunks, as in
        // webpack, but we can have a route -> [chunk] map or something
        this.assets = {};
        if (typeof compiler.input === 'string') {
            compiler.chunks.forEach(function (chunk) {
                if (compiler.input in chunk.modules) {
                    _this.assets.main = chunk.fileName;
                }
            });
        }
        else {
            var _loop_1 = function (name) {
                var file = compiler.input[name];
                this_1.assets[name] = compiler.chunks.find(function (chunk) { return file in chunk.modules; }).fileName;
            };
            var this_1 = this;
            for (var name in compiler.input) {
                _loop_1(name);
            }
        }
        this.summary = compiler.chunks.map(function (chunk) {
            var size_color = chunk.code.length > 150000 ? __chunk_4.colors.bold.red : chunk.code.length > 50000 ? __chunk_4.colors.bold.yellow : __chunk_4.colors.bold.white;
            var size_label = __chunk_4.left_pad(prettyBytes.default(chunk.code.length), 10);
            var lines = [size_color(size_label + " " + chunk.fileName)];
            var deps = Object.keys(chunk.modules)
                .map(function (file) {
                return {
                    file: path.relative(process.cwd(), file),
                    size: chunk.modules[file].renderedLength
                };
            })
                .filter(function (dep) { return dep.size > 0; })
                .sort(function (a, b) { return b.size - a.size; });
            var total_unminified = deps.reduce(function (t, d) { return t + d.size; }, 0);
            deps.forEach(function (dep, i) {
                var c = i === deps.length - 1 ? '└' : '│';
                var line = "           " + c + " " + dep.file;
                if (deps.length > 1) {
                    var p = (100 * dep.size / total_unminified).toFixed(1);
                    line += " (" + p + "%)";
                }
                lines.push(__chunk_4.colors.gray(line));
            });
            return lines.join('\n');
        }).join('\n');
    }
    RollupResult.prototype.to_json = function (manifest_data, dirs) {
        // TODO extract_css has side-effects that don't belong
        // in a method called to_json
        return {
            bundler: 'rollup',
            shimport: require('shimport/package.json').version,
            assets: this.assets,
            css: extract_css(this, manifest_data.components, dirs)
        };
    };
    RollupResult.prototype.print = function () {
        var blocks = this.warnings.map(function (warning) {
            return warning.file
                ? "> " + __chunk_4.colors.bold(warning.file) + "\n" + warning.message
                : "> " + warning.message;
        });
        blocks.push(this.summary);
        return blocks.join('\n\n');
    };
    return RollupResult;
}());
function munge_warning_or_error(warning_or_error) {
    return {
        file: warning_or_error.filename,
        message: [warning_or_error.message, warning_or_error.frame].filter(Boolean).join('\n')
    };
}

var rollup;
var RollupCompiler = /** @class */ (function () {
    function RollupCompiler(config) {
        this._ = this.get_config(config);
        this.input = null;
        this.warnings = [];
        this.errors = [];
        this.chunks = [];
        this.css_files = [];
    }
    RollupCompiler.prototype.get_config = function (mod) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var onwarn;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                // TODO this is hacky, and doesn't need to apply to all three compilers
                (mod.plugins || (mod.plugins = [])).push({
                    name: 'sapper-internal',
                    options: function (opts) {
                        _this.input = opts.input;
                    },
                    renderChunk: function (code, chunk) {
                        _this.chunks.push(chunk);
                    },
                    transform: function (code, id) {
                        if (/\.css$/.test(id)) {
                            _this.css_files.push({ id: id, code: code });
                            return "";
                        }
                    }
                });
                onwarn = mod.onwarn || (function (warning, handler) {
                    handler(warning);
                });
                mod.onwarn = function (warning) {
                    onwarn(warning, function (warning) {
                        _this.warnings.push(warning);
                    });
                };
                return [2 /*return*/, mod];
            });
        });
    };
    RollupCompiler.prototype.oninvalid = function (cb) {
        this._oninvalid = cb;
    };
    RollupCompiler.prototype.compile = function () {
        return tslib_1.__awaiter(this, void 0, Promise, function () {
            var config, start, bundle, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._];
                    case 1:
                        config = _a.sent();
                        start = Date.now();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 5, , 6]);
                        return [4 /*yield*/, rollup.rollup(config)];
                    case 3:
                        bundle = _a.sent();
                        return [4 /*yield*/, bundle.write(config.output)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, new RollupResult(Date.now() - start, this)];
                    case 5:
                        err_1 = _a.sent();
                        if (err_1.filename) {
                            // TODO this is a bit messy. Also, can
                            // Rollup emit other kinds of error?
                            err_1.message = [
                                "Failed to build \u2014 error in " + err_1.filename + ": " + err_1.message,
                                err_1.frame
                            ].filter(Boolean).join('\n');
                        }
                        throw err_1;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    RollupCompiler.prototype.watch = function (cb) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var config, watcher;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._];
                    case 1:
                        config = _a.sent();
                        watcher = rollup.watch(config);
                        watcher.on('change', function (id) {
                            _this.chunks = [];
                            _this.warnings = [];
                            _this.errors = [];
                            _this._oninvalid(id);
                        });
                        watcher.on('event', function (event) {
                            switch (event.code) {
                                case 'FATAL':
                                    // TODO kill the process?
                                    if (event.error.filename) {
                                        // TODO this is a bit messy. Also, can
                                        // Rollup emit other kinds of error?
                                        event.error.message = [
                                            "Failed to build \u2014 error in " + event.error.filename + ": " + event.error.message,
                                            event.error.frame
                                        ].filter(Boolean).join('\n');
                                    }
                                    cb(event.error);
                                    break;
                                case 'ERROR':
                                    _this.errors.push(event.error);
                                    cb(null, new RollupResult(Date.now() - _this._start, _this));
                                    break;
                                case 'START':
                                case 'END':
                                    // TODO is there anything to do with this info?
                                    break;
                                case 'BUNDLE_START':
                                    _this._start = Date.now();
                                    break;
                                case 'BUNDLE_END':
                                    cb(null, new RollupResult(Date.now() - _this._start, _this));
                                    break;
                                default:
                                    console.log("Unexpected event " + event.code);
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    RollupCompiler.load_config = function (cwd) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var input, bundle, resp, code, defaultLoader, config;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!rollup)
                            rollup = requireRelative_1('rollup', cwd);
                        input = path.resolve(cwd, 'rollup.config.js');
                        return [4 /*yield*/, rollup.rollup({
                                input: input,
                                inlineDynamicImports: true,
                                external: function (id) {
                                    return (id[0] !== '.' && !path.isAbsolute(id)) || id.slice(-5, id.length) === '.json';
                                }
                            })];
                    case 1:
                        bundle = _a.sent();
                        return [4 /*yield*/, bundle.generate({ format: 'cjs' })];
                    case 2:
                        resp = _a.sent();
                        code = (resp.output ? resp.output[0] : resp).code;
                        defaultLoader = require.extensions['.js'];
                        require.extensions['.js'] = function (module, filename) {
                            if (filename === input) {
                                module._compile(code, filename);
                            }
                            else {
                                defaultLoader(module, filename);
                            }
                        };
                        config = require(input);
                        delete require.cache[input];
                        return [2 /*return*/, config];
                }
            });
        });
    };
    return RollupCompiler;
}());

/**
 * This has been adapted from `create-react-app`, authored by Facebook, Inc.
 * see: https://github.com/facebookincubator/create-react-app/tree/master/packages/react-dev-utils
 */

const { inverse } = __chunk_4.kleur;

const errorLabel = 'Syntax error:';
const isLikelyASyntaxError = str => str.includes(errorLabel);

const exportRegex = /\s*(.+?)\s*(")?export '(.+?)' was not found in '(.+?)'/;
const stackRegex = /^\s*at\s((?!webpack:).)*:\d+:\d+[\s\)]*(\n|$)/gm;

function formatMessage(message, isError) {
  let lines = message.split('\n');

  if (lines.length > 2 && lines[1] === '') {
    lines.splice(1, 1); // Remove extra newline.
  }

  // Remove loader notation from filenames:
  //   `./~/css-loader!./src/App.css` ~~> `./src/App.css`
  if (lines[0].lastIndexOf('!') !== -1) {
    lines[0] = lines[0].substr(lines[0].lastIndexOf('!') + 1);
  }

	// Remove useless `entry` filename stack details
  lines = lines.filter(line => line.indexOf(' @ ') !== 0);

  // 0 ~> filename; 1 ~> main err msg
  if (!lines[0] || !lines[1]) {
    return lines.join('\n');
  }

  // Cleans up verbose "module not found" messages for files and packages.
  if (lines[1].startsWith('Module not found: ')) {
    lines = [
      lines[0],
      lines[1] // "Module not found: " is enough detail
        .replace("Cannot resolve 'file' or 'directory' ", '')
        .replace('Cannot resolve module ', '')
        .replace('Error: ', '')
        .replace('[CaseSensitivePathsPlugin] ', '')
    ];
  }

  // Cleans up syntax error messages.
  if (lines[1].startsWith('Module build failed: ')) {
    lines[1] = lines[1].replace('Module build failed: SyntaxError:', errorLabel);
  }

  if (lines[1].match(exportRegex)) {
    lines[1] = lines[1].replace(exportRegex, "$1 '$4' does not contain an export named '$3'.");
  }

  lines[0] = inverse(lines[0]);

  // Reassemble & Strip internal tracing, except `webpack:` -- (create-react-app/pull/1050)
  return lines.join('\n').replace(stackRegex, '').trim();
}

var webpackFormatMessages = function (stats) {
	const json = stats.toJson({}, true);

	const result = {
		errors: json.errors.map(msg => formatMessage(msg, true)),
		warnings: json.warnings.map(msg => formatMessage(msg, false))
	};

	// Only show syntax errors if we have them
  if (result.errors.some(isLikelyASyntaxError)) {
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  // First error is usually it; others usually the same
  if (result.errors.length > 1) {
    result.errors.length = 1;
  }

  return result;
};

var formatMessage_1 = formatMessage;
webpackFormatMessages.formatMessage = formatMessage_1;

var locPattern = /\((\d+):(\d+)\)$/;
function munge_warning_or_error$1(message) {
    // TODO this is all a bit rube goldberg...
    var lines = message.split('\n');
    var file = lines.shift()
        .replace('[7m', '') // careful — there is a special character at the beginning of this string
        .replace('[27m', '')
        .replace('./', '');
    var line = null;
    var column = null;
    var match = locPattern.exec(lines[0]);
    if (match) {
        lines[0] = lines[0].replace(locPattern, '');
        line = +match[1];
        column = +match[2];
    }
    return {
        file: file,
        message: lines.join('\n')
    };
}
var WebpackResult = /** @class */ (function () {
    function WebpackResult(stats) {
        this.stats = stats;
        var info = stats.toJson();
        var messages = webpackFormatMessages(stats);
        this.errors = messages.errors.map(munge_warning_or_error$1);
        this.warnings = messages.warnings.map(munge_warning_or_error$1);
        this.duration = info.time;
        this.chunks = info.assets.map(function (chunk) { return ({ file: chunk.name }); });
        this.assets = info.assetsByChunkName;
    }
    WebpackResult.prototype.to_json = function (manifest_data, dirs) {
        var _this = this;
        var extract_css = function (assets) {
            assets = Array.isArray(assets) ? assets : [assets];
            return assets.find(function (asset) { return /\.css$/.test(asset); });
        };
        return {
            bundler: 'webpack',
            shimport: null,
            assets: this.assets,
            css: {
                main: extract_css(this.assets.main),
                chunks: Object
                    .keys(this.assets)
                    .filter(function (chunkName) { return chunkName !== 'main'; })
                    .reduce(function (chunks, chukName) {
                    var assets = _this.assets[chukName];
                    chunks[chukName] = extract_css(assets);
                    return chunks;
                }, {})
            }
        };
    };
    WebpackResult.prototype.print = function () {
        return this.stats.toString({ colors: true });
    };
    return WebpackResult;
}());

var webpack;
var WebpackCompiler = /** @class */ (function () {
    function WebpackCompiler(config) {
        if (!webpack)
            webpack = requireRelative_1('webpack', process.cwd());
        this._ = webpack(config);
    }
    WebpackCompiler.prototype.oninvalid = function (cb) {
        this._.hooks.invalid.tap('sapper', cb);
    };
    WebpackCompiler.prototype.compile = function () {
        var _this = this;
        return new Promise(function (fulfil, reject) {
            _this._.run(function (err, stats) {
                if (err) {
                    reject(err);
                    process.exit(1);
                }
                var result = new WebpackResult(stats);
                if (result.errors.length) {
                    console.error(stats.toString({ colors: true }));
                    reject(new Error("Encountered errors while building app"));
                }
                else {
                    fulfil(result);
                }
            });
        });
    };
    WebpackCompiler.prototype.watch = function (cb) {
        this._.watch({}, function (err, stats) {
            cb(err, stats && new WebpackResult(stats));
        });
    };
    return WebpackCompiler;
}());

function create_compilers(bundler, cwd, src, dest, dev) {
    return tslib_1.__awaiter(this, void 0, Promise, function () {
        var config, config;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    __chunk_5.set_dev(dev);
                    __chunk_5.set_src(src);
                    __chunk_5.set_dest(dest);
                    if (!(bundler === 'rollup')) return [3 /*break*/, 2];
                    return [4 /*yield*/, RollupCompiler.load_config(cwd)];
                case 1:
                    config = _a.sent();
                    validate_config(config, 'rollup');
                    normalize_rollup_config(config.client);
                    normalize_rollup_config(config.server);
                    if (config.serviceworker) {
                        normalize_rollup_config(config.serviceworker);
                    }
                    return [2 /*return*/, {
                            client: new RollupCompiler(config.client),
                            server: new RollupCompiler(config.server),
                            serviceworker: config.serviceworker && new RollupCompiler(config.serviceworker)
                        }];
                case 2:
                    if (bundler === 'webpack') {
                        config = require(path.resolve(cwd, 'webpack.config.js'));
                        validate_config(config, 'webpack');
                        return [2 /*return*/, {
                                client: new WebpackCompiler(config.client),
                                server: new WebpackCompiler(config.server),
                                serviceworker: config.serviceworker && new WebpackCompiler(config.serviceworker)
                            }];
                    }
                    // this shouldn't be possible...
                    throw new Error("Invalid bundler option '" + bundler + "'");
            }
        });
    });
}
function validate_config(config, bundler) {
    if (!config.client || !config.server) {
        throw new Error(bundler + ".config.js must export a { client, server, serviceworker? } object");
    }
}
function normalize_rollup_config(config) {
    if (typeof config.input === 'string') {
        config.input = path.normalize(config.input);
    }
    else {
        for (var name in config.input) {
            config.input[name] = path.normalize(config.input[name]);
        }
    }
}

function create_manifest_data(cwd) {
    // TODO remove in a future version
    if (!fs.existsSync(cwd)) {
        throw new Error("As of Sapper 0.21, the routes/ directory should become src/routes/");
    }
    var components = [];
    var pages = [];
    var server_routes = [];
    var default_layout = {
        default: true,
        name: '_default_layout',
        file: null
    };
    function walk(dir, parent_segments, parent_params, stack) {
        var items = fs.readdirSync(dir)
            .map(function (basename) {
            var resolved = path.join(dir, basename);
            var file = path.relative(cwd, resolved);
            var is_dir = fs.statSync(resolved).isDirectory();
            var ext = path.extname(basename);
            if (!is_dir && !/^\.[a-z]+$/i.test(ext))
                return null; // filter out tmp files etc
            var segment = is_dir
                ? basename
                : basename.slice(0, -path.extname(basename).length);
            var parts = get_parts(segment);
            var is_index = is_dir ? false : basename.startsWith('index.');
            var is_page = ext === '.html';
            parts.forEach(function (part) {
                if (/\]\[/.test(part.content)) {
                    throw new Error("Invalid route " + file + " \u2014 parameters must be separated");
                }
                if (part.qualifier && /[\(\)\?\:]/.test(part.qualifier.slice(1, -1))) {
                    throw new Error("Invalid route " + file + " \u2014 cannot use (, ), ? or : in route qualifiers");
                }
            });
            return {
                basename: basename,
                parts: parts,
                file: __chunk_4.posixify(file),
                is_dir: is_dir,
                is_index: is_index,
                is_page: is_page
            };
        })
            .filter(Boolean)
            .sort(comparator);
        items.forEach(function (item) {
            if (item.basename[0] === '_')
                return;
            if (item.basename[0] === '.') {
                if (item.file !== '.well-known')
                    return;
            }
            var segments = parent_segments.slice();
            if (item.is_index && segments.length > 0) {
                var last_segment = segments[segments.length - 1].slice();
                var suffix = item.basename
                    .slice(0, -path.extname(item.basename).length).
                    replace('index', '');
                if (suffix) {
                    var last_part = last_segment[last_segment.length - 1];
                    if (last_part.dynamic) {
                        last_segment.push({ dynamic: false, content: suffix });
                    }
                    else {
                        last_segment[last_segment.length - 1] = {
                            dynamic: false,
                            content: "" + last_part.content + suffix
                        };
                    }
                    segments[segments.length - 1] = last_segment;
                }
            }
            else {
                segments.push(item.parts);
            }
            var params = parent_params.slice();
            params.push.apply(params, item.parts.filter(function (p) { return p.dynamic; }).map(function (p) { return p.content; }));
            if (item.is_dir) {
                var index = path.join(dir, item.basename, '_layout.html');
                var component = fs.existsSync(index) && {
                    name: get_slug(item.file) + "__layout",
                    file: item.file + "/_layout.html"
                };
                if (component)
                    components.push(component);
                walk(path.join(dir, item.basename), segments, params, component
                    ? stack.concat({ component: component, params: params })
                    : stack.concat(null));
            }
            else if (item.is_page) {
                var component = {
                    name: get_slug(item.file),
                    file: item.file
                };
                var parts = stack.concat({
                    component: component,
                    params: params
                });
                components.push(component);
                if (item.basename === 'index.html') {
                    pages.push({
                        pattern: get_pattern(parent_segments, true),
                        parts: parts
                    });
                }
                else {
                    pages.push({
                        pattern: get_pattern(segments, true),
                        parts: parts
                    });
                }
            }
            else {
                server_routes.push({
                    name: "route_" + get_slug(item.file),
                    pattern: get_pattern(segments, false),
                    file: item.file,
                    params: params
                });
            }
        });
    }
    var root_file = path.join(cwd, '_layout.html');
    var root = fs.existsSync(root_file)
        ? {
            name: 'main',
            file: '_layout.html'
        }
        : default_layout;
    walk(cwd, [], [], []);
    // check for clashes
    var seen_pages = new Map();
    pages.forEach(function (page) {
        var pattern = page.pattern.toString();
        if (seen_pages.has(pattern)) {
            var file = page.parts.pop().component.file;
            var other_page = seen_pages.get(pattern);
            var other_file = other_page.parts.pop().component.file;
            throw new Error("The " + other_file + " and " + file + " pages clash");
        }
        seen_pages.set(pattern, page);
    });
    var seen_routes = new Map();
    server_routes.forEach(function (route) {
        var pattern = route.pattern.toString();
        if (seen_routes.has(pattern)) {
            var other_route = seen_routes.get(pattern);
            throw new Error("The " + other_route.file + " and " + route.file + " routes clash");
        }
        seen_routes.set(pattern, route);
    });
    return {
        root: root,
        components: components,
        pages: pages,
        server_routes: server_routes
    };
}
function comparator(a, b) {
    if (a.is_index !== b.is_index)
        return a.is_index ? -1 : 1;
    var max = Math.max(a.parts.length, b.parts.length);
    for (var i = 0; i < max; i += 1) {
        var a_sub_part = a.parts[i];
        var b_sub_part = b.parts[i];
        if (!a_sub_part)
            return 1; // b is more specific, so goes first
        if (!b_sub_part)
            return -1;
        if (a_sub_part.dynamic !== b_sub_part.dynamic) {
            return a_sub_part.dynamic ? 1 : -1;
        }
        if (!a_sub_part.dynamic && a_sub_part.content !== b_sub_part.content) {
            return ((b_sub_part.content.length - a_sub_part.content.length) ||
                (a_sub_part.content < b_sub_part.content ? -1 : 1));
        }
        // If both parts dynamic, check for regexp patterns
        if (a_sub_part.dynamic && b_sub_part.dynamic) {
            var regexp_pattern = /\((.*?)\)/;
            var a_match = regexp_pattern.exec(a_sub_part.content);
            var b_match = regexp_pattern.exec(b_sub_part.content);
            if (!a_match && b_match) {
                return 1; // No regexp, so less specific than b
            }
            if (!b_match && a_match) {
                return -1;
            }
            if (a_match && b_match && a_match[1] !== b_match[1]) {
                return b_match[1].length - a_match[1].length;
            }
        }
    }
}
function get_parts(part) {
    return part.split(/\[(.+)\]/)
        .map(function (str, i) {
        if (!str)
            return null;
        var dynamic = i % 2 === 1;
        var _a = dynamic
            ? /([^(]+)(\(.+\))?$/.exec(str)
            : [, str, null], content = _a[1], qualifier = _a[2];
        return {
            content: content,
            dynamic: dynamic,
            qualifier: qualifier
        };
    })
        .filter(Boolean);
}
function get_slug(file) {
    var name = file
        .replace(/[\\\/]index/, '')
        .replace(/_default([\/\\index])?\.html$/, 'index')
        .replace(/[\/\\]/g, '_')
        .replace(/\.\w+$/, '')
        .replace(/\[([^(]+)(?:\([^(]+\))?\]/, '$$$1')
        .replace(/[^a-zA-Z0-9_$]/g, function (c) {
        return c === '.' ? '_' : "$" + c.charCodeAt(0);
    });
    if (__chunk_4.reserved_words.has(name))
        name += '_';
    return name;
}
function get_pattern(segments, add_trailing_slash) {
    return new RegExp("^" +
        segments.map(function (segment) {
            return '\\/' + segment.map(function (part) {
                return part.dynamic
                    ? part.qualifier || '([^\\/]+?)'
                    : encodeURI(part.content.normalize())
                        .replace(/\?/g, '%3F')
                        .replace(/#/g, '%23')
                        .replace(/%5B/g, '[')
                        .replace(/%5D/g, ']');
            }).join('');
        }).join('') +
        (add_trailing_slash ? '\\\/?$' : '$'));
}

exports.create_compilers = create_compilers;
exports.create_manifest_data = create_manifest_data;
exports.create_main_manifests = create_main_manifests;
exports.create_serviceworker_manifest = create_serviceworker_manifest;
//# sourceMappingURL=core.js.map
